<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1466630165330">{:repl-history {:ide [], :local [&quot;(ns datomix.commons)&quot; &quot;(defn datamic-var?\n  \&quot;Is symbol a datomic variable\&quot;\n  [ a ]\n  (and (symbol? a) (.startsWith (name a) \&quot;?\&quot;)))&quot; &quot;(defn mash-up\n  \&quot;Merge collections of given type\&quot;\n  [ &amp; collections ]\n  (let [ head-col (first collections) ]\n    (cond\n      (set? head-col) (apply clojure.set/union collections)\n      (vector? head-col) (into [] (apply concat collections))\n      (seq? head-col) (apply concat collections)\n      (map? head-col) (reduce (partial merge-with mash-up) collections)\n      :else head-col)))&quot; &quot;(ns datomix.core\n  (:require [datomix.commons])\n  (:require [datomic.api :as d]))&quot; &quot;(ns datomix.core\n  (:require [datomix.commons]))&quot; &quot;(ns datomix.core\n  (:use [datomix.commons]))&quot; &quot;(mash-up {:a 1 } {:b 2})&quot; &quot;(ns datomix.commons\n  (:use [clojure.set]))&quot; &quot;(type (first {:a 1 }))&quot; &quot;(type? (first {:a 1 }))&quot; &quot;(type 10)&quot; &quot;(clojure.core/type 10)&quot; &quot;(ns datomix.commons\n  (:require [clojure.set]))&quot; &quot;(clojure.core/type (first {:a 1 }))&quot; &quot;(defn map-entry?\n  \&quot;Checks if the value is an map entry\&quot;\n  [e]\n  (= 'clojure.lang.MapEntry (type e)))&quot; &quot;(defn map-entry?\n  \&quot;Checks if the value is an map entry\&quot;\n  [e]\n  (= clojure.lang.MapEntry (type e)))&quot; &quot;(map-entry? (first {:a 1 }))&quot; &quot;(map-entry? 10)&quot; &quot;(ns datomix.core\n  (:use [datomix.commons])\n  (:require [datomic.api :as d]))&quot; &quot;(defmacro qx\n  \&quot;Query with mapping\&quot;\n  [ original-query &amp; args ]\n  (let[ unquoted-query (unquote-sentence original-query)\n       result-mapping (extract-mapping unquoted-query)\n       [ is-maps-list is-grouping-query cleaned-mapping ] (has-group-by result-mapping)\n       found-vars (deep-filter datamic-var? cleaned-mapping) ]\n    (let [query (reshape-query unquoted-query  found-vars)]\n      `(binding [  *warn-on-reflection* false ]\n         (let[ result# (datomic.api/q  (quote ~query) ~@args ) ]\n            (let[ qex# (map (fn[  ~found-vars  ] ~cleaned-mapping )   result#  ) ]\n              (if ~is-grouping-query\n                (if ~is-maps-list (group-by-maps qex#) (apply mash-up qex#))  qex# )))))))&quot; &quot;(ns datomix.examples\n  (:use datomix.core))&quot; &quot;(qx [:find   {:key ?k :val #{ ?pathElem ... }}\n     :in [[?k ?v]]\n     :where [ (.endsWith ?k \&quot;path\&quot;)]\n     [(.split ?v \&quot;;\&quot;) [?pathElem ...]]\n     [(.endsWith ?pathElem \&quot;.jar\&quot;)]]\n    (System/getProperties))&quot;], :remote []}}</component>
</project>